# 브라우저의 동작원리

### 브라우저의 기본 구조
![image](https://github.com/howooking/CS_Study_for_Interview/assets/87072568/4ad654f3-f1c5-463f-91d7-87945da5efc9)
1. 사용자 인터페이스: 주소표시줄, 뒤로가기, 북마크 등... 요청한 페이지가 보여지는 창을 제외한 부분.
2. 브라우저 엔진: `사용자 인터페이스`와 `렌더링 엔진` 사이의 동작 제어.
3. 렌더링 엔진: 요청한 콘텐츠(HTML, 이미지)를 표시.
4. 통신: HTTP요청과 같은 네트워크 호출에 사용.
5. 자바스크립트 해석기: 자바스크립트 엔진
6. UI 백엔드: 브라우저에서 명시하지 않은 일반적인 인터페이스, OS 사용자 인터페이스 체계를 사용, 렌더트리를 그리는 역할
7. 자료저장소: 쿠키, 세션, 로컬 저장소 등을 보조기억장치에 저장

### 렌더링 엔진 동작 과정
![image](https://github.com/howooking/CS_Study_for_Interview/assets/87072568/5489d187-220b-4bd6-beb7-6f0cbf39b613)
1. 통신으로 HTML, CSS를 받고 각각 파싱(브라우저가 코드를 이해하고 사용할 수 있는 구조로 변환하는 것)을 한다.
2. HTML을 기반으로 돔트리를 만든다.
3. CSS을 기반으로 CSSOM를 만들고 돔트리와 결합하여 렌더 트리를 만든다.
4. 렌더트리 배치: 각 노드가 화면에 정확히 표시되는 것을 의미.
5. 렌터트리 그리기: UI 백엔드에서 렌더트리의 각 노드들을 형상으로 만들어낸다.

- 실제 렌더링 엔진은 좀 더 나은 사용자 경험을 위해 모든 HTML을 파싱할 때까지 기다리지 않고(비동기적) 배치와 그리기 과정을 시작한다. 네트워크로부터 나머지 내용이 전송되기를 기다리는 동시에 받은 내용의 일부를 먼저 화면에 표시하는 것이다.

# Document Object Model
<img width="563" alt="image" src="https://github.com/howooking/CS_Study_for_Interview/assets/87072568/c76caef4-16d7-402c-b381-ceda760484f4">

### What ?
- Document = file(html) , Object = tags(`<div></div>`), Model = layout, structure (트리구조)
- 문서(document)를 트리구조로(model) 객체화(object) 시켰다.
### Why ?
- 자바스크립트는 DOM을 조작하기 위해 만들어진 언어다.
- DOM을 통해 쉽게 요소들에 대해 CRUD가 가능.
- 최상위 객체(노드)는 document이며 웹페이지 자체를 의미
- document.getElementById("name")...

# CORS
### 사전지식, SOP(Same Origin Policy)
- 다른 출처(origin)의 리소스를 사용하는 것을 제한하는 보안 방식
- Origin이란?
  - URL의 protocol, host(domain), port를 통해 정함
  - `https://` `github.com` `:3000`/howooking
  - 이중 하나라도 다르면 다른 출처로 인식함
- why?
  - 패캠`https://fastcampus.com`은 로그인만 하여도 추가적인 인증절차없이 강의를 결제할 수 있다고 가정하자.
  - 내가 패캠에 로그인을 하면 패캠에서는 인증토큰을 보내주고 브라우저에 저장된다.
  - 해커가 나에게 `http://hacker.com`로 접속을 유도한다.
  - 해커가 만든 사이트의 html, css, js가 내 브라우저에 받아진다.
  - 해커는 js에 나의 인증토큰을 담아서 패캠에게 모든 강의를 결제하라는 코드를 심는다.
  - 이 때 패캠에서는 `http://hacker.com`로부터 결제 요청을 받게된다.
  - 패캠은 요청의 origin을 확인하고 SOP에 따라 요청을 막는다.
- problem
  - 선량한 개발자인 나는 모든 인강 정보를 보여주는 사이트`https://lectures.com`를 만들고자 한다.
  - 패캠의 모든 강의목록을 불러오는 api(있다고 가정)를 통해 요청을 하게 되면 똑같은 문제가 발생
  - 다른 출처의 리소스가 필요하다면 어떻게 할까? 👉 CORS
### CORS ?
- 원래 다른 출처로부터 데이터를 주고 받는 것은 SOP에 의해 금지되어있으나 웹 생태계가 다양해지면서 여러 서비스들간의 데이터 교환이 필요해졌고 이를 위해 CORS가 등장.
- Cross Origin Resource Sharing, 다른 출처의 자원을 공유
- HTTP헤더를 사용하여 한 origin에서 다른 origin의 자원에 접근할 수 있는 권한을 부여하도록 `브라우저`에 알려주는 체제.
### CORS 접근제어 시나리오

- Preflight request
  ![image](https://github.com/howooking/CS_Study_for_Interview/assets/87072568/c80226a8-709e-415d-a7d6-fe0561fd658c)
  
  - 요청을 보내기 전에 요청을 보내도 되는지를 물어보는 작업
  <img width="396" alt="image" src="https://github.com/howooking/CS_Study_for_Interview/assets/87072568/3ac7668f-11fb-4e5a-8b1c-c9aa0ce38f1d">

  - preflight 요청은 HTTP 의 OPTIONS 메서드를 사용하며 Access-Control-Request-* 형태의 헤더로 전송한다.
 
  <img width="384" alt="image" src="https://github.com/howooking/CS_Study_for_Interview/assets/87072568/71b22720-9424-4dd4-9284-a4afae5bf583">
  
  - 항상 두번의 요청, 응답이 발생하므로 Access-Control-Max-Age 까지 캐싱을 해두고 두번째 요청부터는 바로 본 응답을 해준다.
  - `PUT`, `DELETE`와 같은 요청은 서버 데이터에 영향을 줄 수 있으므로 이러한 요청은 반드시 preflight로 진행해야함.
 
- Simple request
  ![image](https://github.com/howooking/CS_Study_for_Interview/assets/87072568/1e8053b6-3a66-40be-90dc-c69fddff47c6)



  - preflight 요청 없이 바로 요청을 보낸다.
  - 따라서 조건이 많다.
    - `GET`, `HEAD`(GET과 유사하나 header정보만을 보내줌)요청
    - `Content-Type`이 다음과 같은 `POST`요청
      - `application/x-www-form-urlencoded`
      - `multipart/form-data`
      - `text/plain`
    - Header는 다음 만을 허용한다.
      - `Accept`, `Accept-Language`, `Content-Language`, `Content-Type`등.. 몇개 더있음
- Credentialed request
  - 인증 관련 헤더를 포함할 때 사용하는 요청
  - 서버에서 `Access-Control-Allow-Credentials: true`
  - `Access-Control-Allow-Origin: *`는 안되고 origin 명시가 필요하다.

 # 크로스브라우징
 ### What ?
 - 웹페이지가 기기나 웹브라우저의 종류에 구애받지 않고 제작자의의도에 맞게 보여지거나 동작할 수 있게 하는 작업.
 <img width="572" alt="image" src="https://github.com/howooking/CS_Study_for_Interview/assets/87072568/d47ba125-8708-4e47-8c1d-1b69f057afbc">
 
 - 웹브라우저마다 `렌더링엔진`이 다르기 때문에 발생.
 - 따라서 완전히 똑같은 결과물을 보여줄 수는 없으며 개발자는 이러한 차이를 최소화 하여야 함.

### How ?
- 직접 여러 종류의 브라우저에서 테스트를 진행한다.
- 개발 전에 어떤 브라우저를 타겟으로 할 것인지, 몇 버전까지 서비스를 할 건지 등을 미리 정해야.

### Internet Explorer
- 이제는 신경쓰지 않아도 된다.

# 웹 성능과 관련된 Issue
### 웹 성능이 중요한 이유
<img width="706" alt="image" src="https://github.com/howooking/CS_Study_for_Interview/assets/87072568/5f7c6da9-c896-4d09-af5a-1baee878a057">

<img width="701" alt="image" src="https://github.com/howooking/CS_Study_for_Interview/assets/87072568/6b3d56ca-b8f2-41a0-ad7c-bc812f0b696d">

### 웹 성능 평가 지표
#### 구글에서 선정한 웹 선응지표를 `web vital`이라고 하며 `LCP`, `FID`, `CLS`가 있다

1. 로딩속도
- TTFB (Time To First Byte): 페이지를 요청했을 때 서버로부터 첫 byte를 받기까지 걸리는 시간, 서버의 성능과 직결, 반응만 빠르고 로드시간이 느릴경우 의미가 없음
  - 최적화 방법
    - 비싼 서버 
    - 백앤드 로직 최적화
    - db 쿼리 최적화, db 성능개선
- FCP(First Contentful Paint): url접속 후 첫 요소가 로드 될 때까지 걸리는 시간, 실질적으로 사용자경험과는 무관함.
  - 최적화 방법
    - 렌더링을 막는 리소스 제거
    - CSS minify
    - 사용하지 않는 CSS 제거
    - 요청할 origin에 preconnect : <link rel="preconnect">
    - 키 요청 preload : <link rel="preload">
    - 서버 응답 시간 (TTFB) 줄이기
    - 여러 페이지 리다이렉트 줄이기
    - 지나치게 큰 네트워크 payload를 피하기
    - 효율적인 캐싱 전략
    - 과도한 DOM size를 피하기
    - 중요한 요청의 depth를 최소화
    - 웹 폰트 로드 중에 텍스트가 계속 보이도록 함
    - 요청 수를 줄이고 전송 크기를 작게 하기
   
<img width="609" alt="image" src="https://github.com/howooking/CS_Study_for_Interview/assets/87072568/57f00988-a5fb-4142-8b06-1e6c3e6f5bb5">

- FMP(First Meaningful Paint): 사용자에 의미있는 첫 요가 로드 될 때까지 걸리는 시간, 의미있는 이라는 말이 주관적이며 20% 정도에서 정확하지 않다고 함.

  ![image](https://github.com/howooking/CS_Study_for_Interview/assets/87072568/1b0851de-8b55-4305-a15a-e72913e89959)

- LCP(Largest Contentful Paint): 주요콘텐츠(이미지, 비디오)가  로드 될 때까지 걸리는 시간, 현재 대부분 LCP를 기준으로 로딩속도를 측정함.
  - 느린 서버 응답 시간 해결
    - 서버 최적화
    - 가까운 CDN으로 라우팅
    - asset 캐싱
    - cache-first HTML 페이지 서빙
    - 서드파티 origin 리소스 preconnect
  - CSS block 시간 단축
    - CSS minify
    - 중요하지 않은 CSS는 defer로 load
    - 중요 CSS는 inline 으로 load
  - Javascript block 시간 단축
    - JS 파일 minify 및 압축
  - 느린 리소스 (img, svg, video, ...) 로드 시간 해결
    - 이미지 최적화 및 압축
    - 중요한 리소스 preload
    - 텍스트 파일 압축
    - 적응형 리소스 서빙(3g 환경에서 유튜브 화질 안좋음)
    - 서비스 워커를 통한 asset 캐싱
  - CSR의 경우
    - 자바스크립트 minify
    - 사용하지 않는 자바스크립트 defer로 load
    - 사용하지 않는 polyfill 최소화
  - Prerendering 전략
    - SSR
    - SSG
    - ISR
2. CLS(Cumulative Layout Shift)

2. 렌더링
-  한 화면이 그려지는 시간이 60hz이상(16ms)이여야 우리 눈에 자연스럽게 보임 
3. 메모리
- JS는 자동으로 가베지콜렉팅을 하기 때문에 특정 경우들만 조심하면 된다.
4. FID(First Input Delay)
 
