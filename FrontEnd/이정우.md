# 브라우저의 동작원리

### 브라우저의 기본 구조
![image](https://github.com/howooking/CS_Study_for_Interview/assets/87072568/4ad654f3-f1c5-463f-91d7-87945da5efc9)
1. 사용자 인터페이스: 주소표시줄, 뒤로가기, 북마크 등... 요청한 페이지가 보여지는 창을 제외한 부분.
2. 브라우저 엔진: `사용자 인터페이스`와 `렌더링 엔진` 사이의 동작 제어.
3. 렌더링 엔진: 요청한 콘텐츠(HTML, 이미지)를 표시.
4. 통신: HTTP요청과 같은 네트워크 호출에 사용.
5. 자바스크립트 해석기: 자바스크립트 엔진
6. UI 백엔드: 브라우저에서 명시하지 않은 일반적인 인터페이스, OS 사용자 인터페이스 체계를 사용, 렌더트리를 그리는 역할
7. 자료저장소: 쿠키, 세션, 로컬 저장소 등을 보조기억장치에 저장

### 렌더링 엔진 동작 과정
![image](https://github.com/howooking/CS_Study_for_Interview/assets/87072568/5489d187-220b-4bd6-beb7-6f0cbf39b613)
1. 통신으로 HTML, CSS를 받고 각각 파싱(브라우저가 코드를 이해하고 사용할 수 있는 구조로 변환하는 것)을 한다.
2. HTML을 기반으로 돔트리를 만든다.
3. CSS을 기반으로 CSSOM를 만들고 돔트리와 결합하여 렌더 트리를 만든다.
4. 렌더트리 배치: 각 노드가 화면에 정확히 표시되는 것을 의미.
5. 렌터트리 그리기: UI 백엔드에서 렌더트리의 각 노드들을 형상으로 만들어낸다.

- 실제 렌더링 엔진은 좀 더 나은 사용자 경험을 위해 모든 HTML을 파싱할 때까지 기다리지 않고(비동기적) 배치와 그리기 과정을 시작한다. 네트워크로부터 나머지 내용이 전송되기를 기다리는 동시에 받은 내용의 일부를 먼저 화면에 표시하는 것이다.

# Document Object Model
<img width="563" alt="image" src="https://github.com/howooking/CS_Study_for_Interview/assets/87072568/c76caef4-16d7-402c-b381-ceda760484f4">

### What ?
- Document = file(html) , Object = tags(`<div></div>`), Model = layout, structure (트리구조)
- 문서(document)를 트리구조로(model) 객체화(object) 시켰다.
### Why ?
- 자바스크립트는 DOM을 조작하기 위해 만들어진 언어다.
- DOM을 통해 쉽게 요소들에 접근하기 때문에 빠르게 CRUD가 가능.
- document.getElementById("name")...
  - 얘는 자바스크립트 코드가 아님
  - 브라우저에서 제공하는 webapi

# CORS
### 사전지식, SOP(Same Origin Policy)
- 다른 출처(origin)의 리소스를 사용하는 것을 제한하는 보안 방식
- Origin이란?
  - URL의 protocol, host(domain), port를 통해 정함
  - `https://` `github.com` `:3000`/howooking
  - 이중 하나라도 다르면 다른 출처로 인식함
- why?
  - 패캠`https://fastcampus.com`은 로그인만 하여도 추가적인 인증절차없이 강의를 결제할 수 있다고 가정하자.
  - 내가 패캠에 로그인을 하면 패캠에서는 인증토큰을 보내주고 브라우저에 저장된다.
  - 해커가 나에게 `http://hacker.com`로 접속을 유도한다.
  - 해커가 만든 사이트의 html, css, js가 내 브라우저에 받아진다.
  - 해커는 js에 나의 인증토큰을 담아서 패캠에게 모든 강의를 결제하라는 코드를 심는다.
  - 이 때 패캠에서는 `http://hacker.com`로부터 결제 요청을 받게된다.
  - 패캠은 요청의 origin을 확인하고 SOP에 따라 요청을 막는다.
- problem
  - 선량한 개발자인 나는 모든 인강 정보를 보여주는 사이트`https://lectures.com`를 만들고자 한다.
  - 패캠의 모든 강의목록을 불러오는 api(있다고 가정)를 통해 요청을 하게 되면 똑같은 문제가 발생
  - 다른 출처의 리소스가 필요하다면 어떻게 할까? 👉 CORS
### CORS ?
- 원래 다른 출처로부터 데이터를 주고 받는 것은 SOP에 의해 금지되어있으나 웹 생태계가 다양해지면서 여러 서비스들간의 데이터 교환이 필요해졌고 이를 위해 CORS가 등장.
- Cross Origin Resource Sharing, 다른 출처의 자원을 공유
- HTTP헤더를 사용하여 한 origin에서 다른 origin의 자원에 접근할 수 있는 권한을 부여하도록 `브라우저`에 알려주는 체제.
### CORS 접근제어 시나리오

- Preflight request
 
  <img width="500" alt="image" src="https://github.com/howooking/CS_Study_for_Interview/assets/87072568/c80226a8-709e-415d-a7d6-fe0561fd658c">
  
  - 요청을 보내기 전에 요청을 보내도 되는지를 물어보는 작업
  <img width="396" alt="image" src="https://github.com/howooking/CS_Study_for_Interview/assets/87072568/3ac7668f-11fb-4e5a-8b1c-c9aa0ce38f1d">

  - preflight 요청은 HTTP 의 OPTIONS 메서드를 사용하며 Access-Control-Request-* 형태의 헤더로 전송한다.
 
  <img width="384" alt="image" src="https://github.com/howooking/CS_Study_for_Interview/assets/87072568/71b22720-9424-4dd4-9284-a4afae5bf583">
  
  - 항상 두번의 요청, 응답이 발생하므로 Access-Control-Max-Age 까지 캐싱을 해두고 두번째 요청부터는 바로 본 응답을 해준다.
  - `PUT`, `DELETE`와 같은 요청은 서버 데이터에 영향을 줄 수 있으므로 이러한 요청은 반드시 preflight로 진행해야함.
 
- Simple request

  <img width="500" alt="image" src="https://github.com/howooking/CS_Study_for_Interview/assets/87072568/1e8053b6-3a66-40be-90dc-c69fddff47c6">



  - preflight 요청 없이 바로 요청을 보낸다.
  - 따라서 조건이 많다.
    - `GET`, `HEAD`(GET과 유사하나 header정보만을 보내줌)요청
    - `Content-Type`이 다음과 같은 `POST`요청
      - `application/x-www-form-urlencoded`
      - `multipart/form-data`
      - `text/plain`
    - Header는 다음 만을 허용한다.
      - `Accept`, `Accept-Language`, `Content-Language`, `Content-Type`등.. 몇개 더있음
- Credentialed request
  - 인증 관련 헤더를 포함할 때 사용하는 요청
  - 서버에서 `Access-Control-Allow-Credentials: true`
  - `Access-Control-Allow-Origin: *`는 안되고 origin 명시가 필요하다.

 # 크로스브라우징
 ### What ?
 - 웹페이지가 기기나 웹브라우저의 종류에 구애받지 않고 제작자의의도에 맞게 보여지거나 동작할 수 있게 하는 작업.
 <img width="572" alt="image" src="https://github.com/howooking/CS_Study_for_Interview/assets/87072568/d47ba125-8708-4e47-8c1d-1b69f057afbc">
 
 - 웹브라우저마다 `렌더링엔진`이 다르기 때문에 발생.
 - 따라서 완전히 똑같은 결과물을 보여줄 수는 없으며 개발자는 이러한 차이를 최소화 하여야 함.

### How ?
- 직접 여러 종류의 브라우저에서 테스트를 진행한다.
- 개발 전에 어떤 브라우저를 타겟으로 할 것인지, 몇 버전까지 서비스를 할 건지 등을 미리 정해야.

### Internet Explorer
- 이제는 신경쓰지 않아도 된다.

# 웹 성능과 관련된 Issue
### 웹 성능이 중요한 이유
<img width="706" alt="image" src="https://github.com/howooking/CS_Study_for_Interview/assets/87072568/5f7c6da9-c896-4d09-af5a-1baee878a057">

<img width="441" alt="image" src="https://github.com/howooking/CS_Study_for_Interview/assets/87072568/0f137344-6b44-42cd-a0fc-b3109e122080">

- `최소한의 데이터`로 `가장 빠른 시간`에 `사용자가 불편함을 느끼지 않는 최적의 화면`을 띄워야 한다.

### 웹 성능 평가 지표

![image](https://github.com/howooking/CS_Study_for_Interview/assets/87072568/19846f45-9996-434e-a194-bdab1abd83c8)

#### 구글에서 선정한 웹 선응지표를 `web vital`이라고 하며 `LCP`, `FID`, `CLS`가 있다

![image](https://github.com/howooking/CS_Study_for_Interview/assets/87072568/2c7ea7d2-5127-4bd5-83ca-873526c8c0a7)



- TTFB (Time To First Byte)
  - 페이지를 요청했을 때 서버로부터 첫 byte를 받기까지 걸리는 시간.
  - 서버의 성능과 직결, 반응만 빠르고 로드시간이 느릴경우 의미가 없음.
     
  ![image](https://github.com/howooking/CS_Study_for_Interview/assets/87072568/d8ac060b-90e5-4394-8ab0-0aa37afb50e1)

  - 위 이미지에서 start ~ responseStart 시점 사이에 소요된 시간
  - SSR(Server-Side Rendering)을 채택할 때 증가, 서버에서 데이터를 fetch하고 document를 완성하는 데 소요된 시간이 그대로 반영되기 때문.

![image](https://github.com/howooking/CS_Study_for_Interview/assets/87072568/48b3e612-b54e-47fe-9fa6-37001498d141)

- FCP(First Contentful Paint)
  - url접속 후 첫 요소가 로드 될 때까지 걸리는 시간.
  - 1.8초 이내 수준일 때 사용자 경험 측면에서 우수하다고 하며, 일단 페이지가 그냥 흰 화면이 아닌, 뭐라도 보이기 시작한 시점이기 때문에 사용자 입장에서는 실질적으로 로딩의 시작을 인지하기 시작하는 시점
  - 실질적으로 사용자경험과는 무관함.

<img width="609" alt="image" src="https://github.com/howooking/CS_Study_for_Interview/assets/87072568/57f00988-a5fb-4142-8b06-1e6c3e6f5bb5">

- FMP(First Meaningful Paint): 사용자에 의미있는 첫 요가 로드 될 때까지 걸리는 시간, 20% 정도에서 정확하지 않다고 함.

  ![image](https://github.com/howooking/CS_Study_for_Interview/assets/87072568/1b0851de-8b55-4305-a15a-e72913e89959)

- LCP(Largest Contentful Paint)
  - 주요콘텐츠(이미지, 비디오)가  로드 될 때까지 걸리는 시간
  - 현재 대부분 LCP를 기준으로 로딩속도를 측정함.

- CLS(Cumulative Layout Shift)
  - 사용자가 예상하지 못한 레이아웃의 이동이 발생했을 때, 이동 전/후 렌더링된 각각의 두 프레임 사이에서 뷰포트의 크기와 뷰포트 내에서 이동한 요소의 이동 거리 및 크기의 비율을 계산하여 수치화한 것.
  - 무언가 비동기식으로 로드되어 동적으로 DOM 요소가 기존 콘텐츠 위에 추가되면서 발생하는 것이며, 주로 이미지, 동영상, 폰트, 광고 등으로 인한 경우가 많다
  - 완성된 페이지를 렌더링하는 SSR에서 우수
  - 무언가 동적으로 렌더링해야 할 경우 Skeleton/Placeholder UI를 활용
  - 이미지, 비디오 요소에 항상 크기(width/height) 또는 종횡비(aspect-ratio) 속성을 명시하여 미리 필요한 공간을 확보
    
- FID(First Input Delay)
  - 버튼을 클릭하는 등 사용자가 처음으로 사이트의 특정 요소와 상호작용 할 때, 브라우저가 해당 상호작용에 대한 응답으로 이벤트 핸들러를 실행하기 시작하는 순간까지의 시간을 나타냅니다.
  - 브라우저가 즉시 응답할 수 없는 것은 메인 스레드가 다른 작업을 처리하고 있어 차단이 발생함
  - 사용자 경험 측면에서 매우 민감하게 작용하는 부분이기 때문에, 100ms 이하여야 우수하다고 할 수 있습니다.
  - `<input>, <textarea>, <select>` 요소, 앵커 <a> 요소를 기준으로 측정.
